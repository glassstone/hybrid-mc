#ifndef __HYBRIDMC_H_
#define __HYBRIDMC_H_


#include <iostream>
#include <math.h>
#include <limits>
#include <omp.h>

#include <gsl/gsl_randist.h>
#include <gsl/gsl_rng.h>

#include "stats.h"


void seed_gsl_rng(gsl_rng **r);	// Seed a gsl_rng with the Unix time in nanoseconds


template<class TParams, class TLogger>
class THybridMC {
	double *q, *p;		// Position and momentum
	size_t dim;		// Dimensionality of parameter space
	TParams &params;	// Additional parameters passed to pdf
	TLogger &logger;	// Object which gets passed elements in chain
	TStats &stats;		// Logs means and covariance
	
	unsigned int weight;			// # of steps system has spent at current position q
	double *q_workspace, *p_workspace;	// Proposal q and p generated by integrating forward
	gsl_rng *r;				// Random number generator
	
	uint64_t N_accepted, N_rejected;
	
public:
	// Typedefs for log(pdf) and random state functions
	typedef double (*log_pdf_t)(const double *const q, size_t dim, TParams &params);
	typedef double (*rand_state_t)(double *q, size_t dim, gsl_rng *r, TParams &params);
	
	// Constructor & Destructor
	THybridMC(size_t _dim, log_pdf_t _log_pdf, rand_state_t _rand_state, TParams &_params, TLogger &_logger, TStats &_stats);
	~THybridMC();
	
	// Mutators
	void step(unsigned int L, double eta, bool log_step=true);					// Take one hybrid Monte Carlo step
	void tune(unsigned int &L, double &eta, double target_acceptance, unsigned int N_rounds=20);	// Tune L and eta to achieve the desired acceptance rate
	void flush();											// Log the current state
	
	// Accessors
	double acceptance_rate();
	void clear_acceptance_rate();
	
private:
	log_pdf_t log_pdf;		// log(p(q)) = -U(q) , where U(q) is the potential energy of the system at q
	rand_state_t rand_state;	// Generate a random position vector q
	
	void draw_p();							// Draw momentum from unit Gaussian
	void leapfrog(unsigned int L, double eta);			// Leapfrog integrate forward L steps with stepsize eta
	
	double delE_delqi(double eta, size_t i, bool use_workspace);	// Calculate dE/dq_i around q', p'
	double delE_delqi(double eta, size_t i);			// Calculate dE/dq_i around q, p
	
	double H();							// Calculate H(q, p)
	double H_prime();						// Calculate H(q', p')
};

// Encapsulates several Hybrid Monte Carlo objects, which step simultaneously
template<class TParams, class TLogger>
class TParallelHybridMC {
	THybridMC<TParams, TLogger> **hmc;
	TStats **component_stats;
	unsigned int N_hmc;
	
	TParams &params;	// Additional parameters passed to pdf
	TLogger &logger;	// Object which gets passed elements in chain
	TStats &stats;		// Logs means and covariance
	
	size_t dim;		// Dimensionality of parameter space
	double *GR_stat;
	
public:
	// Constructor & Destructor
	TParallelHybridMC(unsigned int _N_hmc, size_t _dim, typename THybridMC<TParams, TLogger>::log_pdf_t _log_pdf, typename THybridMC<TParams, TLogger>::rand_state_t _rand_state, TParams &_params, TLogger &_logger, TStats &_stats);
	~TParallelHybridMC();
	
	// Mutators
	void step(unsigned int L, double eta, bool log_step=true);					// Take one hybrid Monte Carlo step in each HMC sampler
	void tune(unsigned int &L, double &eta, double target_acceptance, unsigned int N_rounds=20);	// Tune L and eta to achieve the desired acceptance rate
	void flush();											// Log the current state in each sampler
	void clear_acceptance_rate();									// Clear the N_accepted and N_rejected counters
	
	void step_multiple(unsigned int N_steps, unsigned int L, double eta, bool log_step=true);	// Take several steps in each sampler
	void calc_GR_stat();										// Calculate the Gelman-Rubin diagnostic along each axis
	void update_stats();										// Update the stats object from the stats of each sampler
	
	// Accessors
	double acceptance_rate() const;		// Return the rate of acceptance of proposal points
	double get_GR_stat(size_t i)const;	// Get Gelman-Rubin statistic for axis i
	
private:
	typename THybridMC<TParams, TLogger>::log_pdf_t log_pdf;	// Target distribution: log(p(q)) = -U(q) , where U(q) is the potential energy of the system at q
	typename THybridMC<TParams, TLogger>::rand_state_t rand_state;	// Generate a random position vector q
};


/** ********************************************************************************************************************************************************************************
 * 
 *  TParallelHybridMC member functions
 * 
 **********************************************************************************************************************************************************************************/

template<class TParams, class TLogger>
TParallelHybridMC<TParams, TLogger>::TParallelHybridMC(unsigned int _N_hmc, size_t _dim, typename THybridMC<TParams, TLogger>::log_pdf_t _log_pdf, typename THybridMC<TParams, TLogger>::rand_state_t _rand_state, TParams &_params, TLogger &_logger, TStats &_stats)
	: hmc(NULL), component_stats(NULL), GR_stat(NULL), log_pdf(_log_pdf), rand_state(_rand_state), params(_params), logger(_logger), stats(_stats), N_hmc(_N_hmc), dim(_dim)
{
	component_stats = new TStats*[N_hmc];
	hmc = new THybridMC<TParams, TLogger>*[N_hmc];
	for(unsigned int i=0; i<N_hmc; i++) {
		component_stats[i] = new TStats(dim);
		hmc[i] = new THybridMC<TParams, TLogger>(dim, log_pdf, rand_state, params, logger, *component_stats[i]);
	}
	GR_stat = new double[dim];
	for(unsigned int i=0; i<dim; i++) { GR_stat[i] = std::numeric_limits<double>::infinity(); }
}

template<class TParams, class TLogger>
TParallelHybridMC<TParams, TLogger>::~TParallelHybridMC() {
	for(unsigned int i=0; i<N_hmc; i++) {
		delete hmc[i];
		delete component_stats[i];
	}
	delete[] hmc;
	delete[] component_stats;
	delete[] GR_stat;
}

template<class TParams, class TLogger>
void TParallelHybridMC<TParams, TLogger>::step(unsigned int L, double eta, bool log_step) {
	#pragma omp parallel for
	for(unsigned int i=0; i<N_hmc; i++) { hmc[i]->step(L, eta, log_step); }
}

template<class TParams, class TLogger>
void TParallelHybridMC<TParams, TLogger>::tune(unsigned int &L, double &eta, double target_acceptance, unsigned int N_rounds) {
	#pragma omp parallel num_threads(N_hmc)
	{
		unsigned int L_i = L;
		double eta_i = eta;
		unsigned int thread_ID = omp_get_thread_num();
		
		hmc[thread_ID]->tune(L_i, eta_i, target_acceptance, N_rounds);
		
		#pragma omp atomic
		L += L_i;
		
		#pragma omp atomic
		eta += eta_i;
	}
	
	L /= (double)N_hmc;
	eta /= (double)N_hmc;
}

template<class TParams, class TLogger>
void TParallelHybridMC<TParams, TLogger>::flush() {
	#pragma omp parallel for
	for(unsigned int i=0; i<N_hmc; i++) { hmc[i]->flush(); }
}

template<class TParams, class TLogger>
void TParallelHybridMC<TParams, TLogger>::clear_acceptance_rate() {
	for(unsigned int i=0; i<N_hmc; i++) { hmc[i]->clear_acceptance_rate(); }
}

template<class TParams, class TLogger>
double TParallelHybridMC<TParams, TLogger>::acceptance_rate() const {
	double accept = 0.;
	for(unsigned int i=0; i<N_hmc; i++) { accept += hmc[i]->acceptance_rate(); }
	return accept / (double)N_hmc;
}

template<class TParams, class TLogger>
void TParallelHybridMC<TParams, TLogger>::step_multiple(unsigned int N_steps, unsigned int L, double eta, bool log_step) {
	#pragma omp parallel for
	for(unsigned int i=0; i<N_hmc; i++) {
		for(unsigned int n=0; n<N_steps; n++) { hmc[i]->step(L, eta, log_step); }
	}
}

template<class TParams, class TLogger>
void TParallelHybridMC<TParams, TLogger>::calc_GR_stat() {
	update_stats();
	Gelman_Rubin_diagnostic(component_stats, N_hmc, GR_stat, dim);
}

template<class TParams, class TLogger>
void TParallelHybridMC<TParams, TLogger>::update_stats() {
	flush();
	stats.clear();
	for(unsigned int i=0; i<N_hmc; i++) {
		stats += *component_stats[i];
	}
}

template<class TParams, class TLogger>
double TParallelHybridMC<TParams, TLogger>::get_GR_stat(size_t i) const {
	assert(i < dim);
	return GR_stat[i];
}


/** ********************************************************************************************************************************************************************************
 * 
 *  THybridMC member functions
 * 
 **********************************************************************************************************************************************************************************/

template<class TParams, class TLogger>
THybridMC<TParams, TLogger>::THybridMC(size_t _dim, log_pdf_t _log_pdf, rand_state_t _rand_state, TParams &_params, TLogger &_logger, TStats &_stats)
	: dim(_dim), log_pdf(_log_pdf), rand_state(_rand_state), params(_params), logger(_logger), stats(_stats), q(NULL), p(NULL), q_workspace(NULL), p_workspace(NULL), r(NULL)
{
	seed_gsl_rng(&r);
	
	q = new double[dim];
	p = new double[dim];
	q_workspace = new double[dim];
	p_workspace = new double[dim];
	
	rand_state(q, dim, r, params);
	weight = 1;
	
	N_accepted = 0;
	N_rejected = 0;
}

template<class TParams, class TLogger>
THybridMC<TParams, TLogger>::~THybridMC() {
	delete[] q;
	delete[] p;
	delete[] q_workspace;
	delete[] p_workspace;
	gsl_rng_free(r);
}

template<class TParams, class TLogger>
void THybridMC<TParams, TLogger>::step(unsigned int L, double eta, bool log_step) {
	// Draw a new momentum from a Gaussian distribution
	draw_p();
	// Calculate the initial energy
	double Delta_H = H();
	// Leapfrog integrate either forwards or backwards to generate (q', p')
	leapfrog(L, eta);
	//if(gsl_rng_uniform(r) < 0.5) { leapfrog(L, eta); } else { leapfrog(L, -eta); }
	// Calculate initial - final energy = H - H'
	Delta_H -= H_prime();
	// Accept with probability min(1, exp(H - H'))
	bool accept = false;
	if(Delta_H > 0) {
		accept = true;
	} else if(gsl_rng_uniform(r) < exp(Delta_H)) {
		accept = true;
	}
	if(accept) {
		if(log_step) {
			#pragma omp critical (logger)
			logger(q, weight);
			
			#pragma omp critical (stats)
			stats(q, weight);
			
			weight = 1;
		}
		// Set q -> q', p -> p'
		double *q_tmp = q;
		double *p_tmp = p;
		q = q_workspace;	// Do the copying by just switching pointers
		p = p_workspace;
		q_workspace = q_tmp;	// q' and p' will be initialized to q and p, respectively, when the next Leapfrog integration begins
		p_workspace = p_tmp;
		N_accepted++;
	} else {
		if(log_step) { weight++; }
		N_rejected++;
	}
}

template<class TParams, class TLogger>
double THybridMC<TParams, TLogger>::H() {
	double H_tmp = 0;
	for(size_t i=0; i<dim; i++) { H_tmp += p[i]*p[i]; }
	H_tmp /= 2;
	H_tmp -= log_pdf(q, dim, params);
	return H_tmp;
}

template<class TParams, class TLogger>
double THybridMC<TParams, TLogger>::H_prime() {
	double H_tmp = 0;
	for(size_t i=0; i<dim; i++) { H_tmp += p_workspace[i]*p_workspace[i]; }
	H_tmp /= 2;
	H_tmp -= log_pdf(q_workspace, dim, params);
	return H_tmp;
}

template<class TParams, class TLogger>
inline void THybridMC<TParams, TLogger>::draw_p() {
	for(size_t i=0; i<dim; i++) { p[i] = gsl_ran_gaussian_ziggurat(r, 1.); }
}

template<class TParams, class TLogger>
inline void THybridMC<TParams, TLogger>::leapfrog(unsigned int L, double eta) {
	// Half-step in p
	for(size_t i=0; i<dim; i++) { p_workspace[i] = p[i] - 0.5*eta*delE_delqi(eta, i); }
	// Full step in q
	for(size_t i=0; i<dim; i++) { q_workspace[i] = q[i] + eta*p[i]; }
	for(unsigned int n=0; n<L-1; n++) {
		// Full step in p
		for(size_t i=0; i<dim; i++) { p_workspace[i] -= eta*delE_delqi(eta, i, true); }
		// Full step in q
		for(size_t i=0; i<dim; i++) { q_workspace[i] += eta*p_workspace[i]; }
	}
	// Half-step in p
	for(size_t i=0; i<dim; i++) { p_workspace[i] -= 0.5*eta*delE_delqi(eta, i, true); }
}

// TODO: Deal with boundaries where E -> +infinity
// Estimate delE/delq_i by sampling E at q_i +- eta/10
template<class TParams, class TLogger>
inline double THybridMC<TParams, TLogger>::delE_delqi(double eta, size_t i, bool use_workspace) {
	double q_i_tmp = q_workspace[i];
	q_workspace[i] += eta/10.;
	double delta_E = -log_pdf(q_workspace, dim, params);
	q_workspace[i] = q_i_tmp - eta/10.;
	delta_E -= -log_pdf(q_workspace, dim, params);
	q_workspace[i] = q_i_tmp;
	return 5.*delta_E/eta;
}

// Overloaded version of above, using q rather than q_workspace
template<class TParams, class TLogger>
inline double THybridMC<TParams, TLogger>::delE_delqi(double eta, size_t i) {
	double q_i_tmp = q[i];
	q[i] += eta/10.;
	double Delta_E = -log_pdf(q, dim, params);
	q[i] = q_i_tmp - eta/10.;
	Delta_E += log_pdf(q, dim, params);
	q[i] = q_i_tmp;
	return 5.*Delta_E/eta;
}

template<class TParams, class TLogger>
double THybridMC<TParams, TLogger>::acceptance_rate() { return (double)N_accepted / (double)(N_accepted + N_rejected); }

template<class TParams, class TLogger>
void THybridMC<TParams, TLogger>::clear_acceptance_rate() { N_accepted = 0; N_rejected = 0; }

template<class TParams, class TLogger>
void THybridMC<TParams, TLogger>::tune(unsigned int &L, double &eta, double target_acceptance, unsigned int N_rounds) {
	unsigned int N_steps = (unsigned int)(20./target_acceptance);	// Step enough times to get ~20 acceptances if eta and L are already correct
	double eta_new, lnc, lnp_0;
	double lnp = log(target_acceptance);
	double n = 3.;
	
	for(unsigned int k=0; k<N_rounds; k++) {
		clear_acceptance_rate();
		for(unsigned int i=0; i<N_steps; i++) { step(L, eta, false); }
		if(N_accepted == 0) {
			eta /= 1.2;
		} else if(N_rejected == 0) {
			eta *= 1.1;
		} else {
			double acceptance = acceptance_rate();
			if(acceptance < 0.9*target_acceptance) {
				eta *= 0.95;
			} else if(acceptance > 1.1*target_acceptance) {
				eta *= 1.05;
			}
			/*
			// The following is based on the model p = c e^(-eta^2) = e^(ln(c) - eta^n)
			lnp_0 = log(acceptance_rate());
			lnc = lnp_0 + pow(eta,n);
			if(lnc < lnp) {		// Acceptance rate is unreachable according to model
				eta /= 1.1;
			} else {
				eta_new = pow(lnc - (lnc - pow(eta,n))*lnp/lnp_0, 1./n);
				if(isnan(eta_new)) {
					std::cout << "ln(c) = " << lnc << "\tln(p) = " << lnp << "\teta = " << eta << "\teta_new^n = " << lnc - (lnc - pow(eta,n))*lnp/lnp_0 << std::endl;
				}
				// Don't allow eta to swing by more than a factor of two
				if(eta_new/eta < 0.9) {
					eta *= 0.9;
				} else if(eta_new/eta > 1.1) {
					eta *= 1.1;
				} else {
					eta = eta_new;
				}
			}
			*/
		}
	}
}

template<class TParams, class TLogger>
void THybridMC<TParams, TLogger>::flush() {
	#pragma omp critical (logger)
	logger(q, weight);
	
	#pragma omp critical (stats)
	stats(q, weight);
	
	weight = 0;
}


// Seed a gsl_rng with the Unix time in nanoseconds
inline void seed_gsl_rng(gsl_rng **r) {
	timespec t_seed;
	clock_gettime(CLOCK_REALTIME, &t_seed);
	long unsigned int seed = 1e9*(long unsigned int)t_seed.tv_sec;
	seed += t_seed.tv_nsec;
	*r = gsl_rng_alloc(gsl_rng_taus);
	gsl_rng_set(*r, seed);
}

#endif // __HYBRIDMC_H_